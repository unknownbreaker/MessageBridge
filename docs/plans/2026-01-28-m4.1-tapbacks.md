# M4.1: Tapbacks (Reactions) â€” Design

## Summary

Display tapbacks from chat.db on message bubbles, send tapbacks via IMCore private API with graceful degradation, and sync in real-time via WebSocket.

## Data Model & Database Layer

### Server

New `Tapback` model and `TapbackType` enum:

```swift
struct Tapback: Codable, Sendable {
    let type: TapbackType
    let sender: String          // handle ID
    let isFromMe: Bool
    let date: Date
    let messageGUID: String     // target message
}

enum TapbackType: Int, Codable, Sendable {
    case love = 2000
    case like = 2001
    case dislike = 2002
    case laugh = 2003
    case emphasis = 2004
    case question = 2005
}
```

### Database Query

In `MessageQueries`, when fetching messages for a conversation:

1. Fetch message rows as usual
2. Run a second query for tapback rows: `associated_message_type` between 2000â€“2005 for those message GUIDs
3. For removal detection: also query 3000â€“3005 rows. A 3000-range row cancels the corresponding 2000-range tapback from the same sender
4. Keep only the latest tapback per (sender, type, target message) after applying removals
5. Attach `[Tapback]` array to each `Message`

### Client

Mirror `Tapback` and `TapbackType` in client models. Add `tapbacks: [Tapback]` to client `Message` struct.

## API & WebSocket

### REST

Existing `GET /conversations/:id/messages` now includes `tapbacks` on each message. No new read endpoint.

New endpoint for sending:

```
POST /messages/:id/tapback
{
    "type": "love",       // love|like|dislike|laugh|emphasis|question
    "action": "add"       // add|remove
}
```

Returns 200 on success. Returns 502 with error message if IMCore fails.

### WebSocket

Add two message types to `WebSocketMessageType`:

- `tapback_added` â€” new tapback detected in chat.db
- `tapback_removed` â€” tapback removal detected

Payload:

```json
{
    "type": "tapback_added",
    "data": {
        "messageGUID": "p:0/...",
        "tapbackType": "love",
        "sender": "+15551234567",
        "isFromMe": false
    }
}
```

### chat.db Watcher

Extend existing `ChatDatabaseWatcher` to detect new rows with `associated_message_type` in 2000â€“3005 range. Emit `tapback_added` or `tapback_removed` WebSocket events.

## IMCore Bridge (Sending)

### Architecture

New Objective-C file: `IMCoreTapbackSender` in `Messaging/`. Swift-callable via bridging header.

### Flow

1. `dlopen` IMCore.framework at runtime
2. Get `IMDaemonController.sharedController()`, connect to daemon
3. Look up `IMChat` by chat identifier
4. `loadMessageWithGUID:completionBlock:` to get target message
5. Get `IMMessageItem`, wrap in `IMTextMessagePartChatItem`
6. Call `sendMessageAcknowledgment:forChatItem:withAssociatedMessageInfo:` with type (2000â€“2005 add, 3000â€“3005 remove)

### Graceful Degradation

```swift
public enum TapbackSendResult {
    case success
    case failed(TapbackSendError)
}

public enum TapbackSendError: Error {
    case frameworkNotAvailable   // IMCore couldn't be loaded
    case daemonConnectionFailed
    case chatNotFound
    case messageNotFound         // nil from loadMessageWithGUID
    case sendFailed(String)      // IMCore error
}
```

API route maps these to HTTP responses: 200 for success, 502 for failures with human-readable error.

### Retry

One retry with short delay for `messageNotFound`. No aggressive retry loops.

## Client UI

### TapbackDecorator + TapbackPill

Uses `BubbleDecorator` protocol. `TapbackDecorator` renders `TapbackPill` at `.topTrailing` when `!message.tapbacks.isEmpty`.

`TapbackPill` groups tapbacks by type, shows emoji + count (if > 1). Example: `â¤ï¸2 ğŸ‘` in a capsule overlapping top-right of bubble.

### Context Menu (Sending)

Add "Tapback" submenu to existing right-click context menu with 6 emoji options. If user already has a tapback of that type, option shows as selected â€” tapping sends remove. Calls `POST /messages/:id/tapback`.

### Feedback

- Success: no toast; WebSocket event updates pill automatically
- Failure: toast "Couldn't send tapback" with error reason

### Real-time Update

On `tapback_added`/`tapback_removed` WebSocket event, update `tapbacks` array on relevant message in `MessagesViewModel`. SwiftUI re-renders just that bubble's decorator.

## Testing

### Server

- **TapbackQueryTests** â€” SQL reads tapbacks from chat.db, groups by message, handles add/remove deduplication
- **TapbackAPITests** â€” REST endpoint validates input, returns proper errors
- **TapbackWebSocketTests** â€” watcher detects tapback rows, broadcasts correct event payloads

### Client

- **TapbackDecoratorTests** â€” `shouldDecorate` correctness, pill renders right emoji/counts
- **TapbackPillTests** â€” grouping logic (dedup, counts, ordering)
- **TapbackActionTests** â€” context menu shows correct state (add vs remove), calls correct endpoint

### Not Unit-Tested

IMCore bridge â€” private API, requires running Messages.app. Manual testing only.

## Acceptance Criteria (from spec.md)

- [ ] Tapback pills appear above message bubble
- [ ] Shows emoji and count for each type
- [ ] Long-press/right-click message to add tapback
- [ ] Picker shows: â¤ï¸ ğŸ‘ ğŸ‘ ğŸ˜‚ â€¼ï¸ â“
- [ ] Tap existing tapback to remove
- [ ] Real-time sync via WebSocket
