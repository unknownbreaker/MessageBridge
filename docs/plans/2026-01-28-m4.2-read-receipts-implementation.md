# M4.2 Read Receipts â€” Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Show "Delivered" / "Read" status below the last sent message in a conversation, and mark conversations as read when opened.

**Architecture:** Add `dateDelivered` and `dateRead` fields from Apple's chat.db to Message models (server + client). Add `DecoratorContext` to BubbleDecorator protocol so decorators can know if a message is the last sent. Create `ReadReceiptDecorator` using existing decorator pattern. Mark-as-read already works via `selectConversation()` â€” no new trigger needed.

**Tech Stack:** Swift, Vapor (server), SwiftUI (client), GRDB (database), XCTest

---

## Task 1: Add `dateDelivered` and `dateRead` to Server Message Model

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/Models/Message.swift`

**Step 1: Add fields to Message struct**

Add two optional Date fields after `tapbacks`:

```swift
public var dateDelivered: Date?
public var dateRead: Date?
```

Update the init to include them with defaults of `nil`:

```swift
public init(
    id: Int64, guid: String, text: String?, date: Date, isFromMe: Bool, handleId: Int64?,
    conversationId: String, attachments: [Attachment] = [], tapbacks: [Tapback] = [],
    dateDelivered: Date? = nil, dateRead: Date? = nil
) {
    // ... existing assignments ...
    self.dateDelivered = dateDelivered
    self.dateRead = dateRead
}
```

**Step 2: Build server to verify no compile errors**

Run: `cd MessageBridgeServer && swift build`
Expected: Build succeeds

**Step 3: Commit**

```
feat(server): add dateDelivered and dateRead to Message model
```

---

## Task 2: Add `dateDelivered` and `dateRead` to Server ProcessedMessage

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/Models/ProcessedMessage.swift`

**Step 1: Add convenience accessors**

Add after the existing `attachments` accessor:

```swift
/// Date message was delivered (forwards to underlying message)
public var dateDelivered: Date? { message.dateDelivered }

/// Date message was read (forwards to underlying message)
public var dateRead: Date? { message.dateRead }
```

**Step 2: Build server**

Run: `cd MessageBridgeServer && swift build`
Expected: Build succeeds

**Step 3: Commit**

```
feat(server): expose dateDelivered/dateRead on ProcessedMessage
```

---

## Task 3: Include `date_delivered` and `date_read` in Database Queries

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/Database/ChatDatabase.swift`

**Step 1: Update `fetchMessagesFromDB` SQL and mapping**

In the SQL query (around line 174), add two columns to the SELECT:

```sql
m.date_delivered,
m.date_read
```

In the row mapping (around line 211), parse the new fields and pass to Message init:

```swift
let dateDeliveredRaw: Int64? = row["date_delivered"]
let dateReadRaw: Int64? = row["date_read"]

return Message(
    id: messageId,
    guid: row["guid"],
    text: messageText,
    date: Message.dateFromAppleTimestamp(row["date"]),
    isFromMe: (row["is_from_me"] as Int?) == 1,
    handleId: row["handle_id"],
    conversationId: conversationId,
    attachments: attachments,
    dateDelivered: dateDeliveredRaw.flatMap { $0 != 0 ? Message.dateFromAppleTimestamp($0) : nil },
    dateRead: dateReadRaw.flatMap { $0 != 0 ? Message.dateFromAppleTimestamp($0) : nil }
)
```

**Step 2: Update `fetchMessagesNewerThan` SQL and mapping**

Same pattern â€” add `m.date_delivered` and `m.date_read` to the SELECT (around line 233) and map them in the row parsing (around line 275):

```swift
let dateDeliveredRaw: Int64? = row["date_delivered"]
let dateReadRaw: Int64? = row["date_read"]

let message = Message(
    id: messageId,
    guid: guid,
    text: messageText,
    date: Message.dateFromAppleTimestamp(row["date"] ?? 0),
    isFromMe: (row["is_from_me"] as Int?) == 1,
    handleId: row["handle_id"],
    conversationId: conversationId,
    dateDelivered: dateDeliveredRaw.flatMap { $0 != 0 ? Message.dateFromAppleTimestamp($0) : nil },
    dateRead: dateReadRaw.flatMap { $0 != 0 ? Message.dateFromAppleTimestamp($0) : nil }
)
```

**Step 3: Run server tests**

Run: `cd MessageBridgeServer && swift test`
Expected: All tests pass

**Step 4: Commit**

```
feat(server): include date_delivered and date_read in message queries
```

---

## Task 4: Add `dateDelivered`, `dateRead`, and `DeliveryStatus` to Client Message Model

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/Models/Models.swift`

**Step 1: Add `DeliveryStatus` enum**

Add above the `Message` struct:

```swift
// MARK: - DeliveryStatus

/// Delivery status of a sent message
public enum DeliveryStatus: String, Codable, Sendable {
    case none       // Received messages (no status shown)
    case sent       // Sent, no delivery confirmation yet
    case delivered  // Delivered to recipient's device
    case read       // Recipient opened conversation
}
```

**Step 2: Add fields to client Message**

Add after `tapbacks`:

```swift
public let dateDelivered: Date?
public let dateRead: Date?
```

Add computed property:

```swift
public var deliveryStatus: DeliveryStatus {
    if dateRead != nil { return .read }
    if dateDelivered != nil { return .delivered }
    if isFromMe { return .sent }
    return .none
}
```

**Step 3: Update CodingKeys**

Add to the CodingKeys enum:

```swift
case dateDelivered, dateRead
```

**Step 4: Update init**

Add parameters with `nil` defaults:

```swift
public init(
    id: Int64, guid: String, text: String?, date: Date, isFromMe: Bool, handleId: Int64?,
    conversationId: String, attachments: [Attachment] = [],
    detectedCodes: [DetectedCode]? = nil,
    highlights: [TextHighlight]? = nil,
    mentions: [Mention]? = nil,
    tapbacks: [Tapback]? = nil,
    dateDelivered: Date? = nil,
    dateRead: Date? = nil
) {
    // ... existing ...
    self.dateDelivered = dateDelivered
    self.dateRead = dateRead
}
```

**Step 5: Update init(from decoder:)**

Add after `tapbacks` decoding:

```swift
dateDelivered = try container.decodeIfPresent(Date.self, forKey: .dateDelivered)
dateRead = try container.decodeIfPresent(Date.self, forKey: .dateRead)
```

**Step 6: Update `ProcessedMessageDTO.toMessage()` in `BridgeConnection.swift`**

The `RawMessageDTO` struct needs the new fields:

```swift
struct RawMessageDTO: Codable {
    let id: Int64
    let guid: String
    let text: String?
    let date: Date
    let isFromMe: Bool
    let handleId: Int64?
    let conversationId: String
    let attachments: [Attachment]?
    let dateDelivered: Date?
    let dateRead: Date?
}

func toMessage() -> Message {
    Message(
        id: message.id,
        guid: message.guid,
        text: message.text,
        date: message.date,
        isFromMe: message.isFromMe,
        handleId: message.handleId,
        conversationId: message.conversationId,
        attachments: message.attachments ?? [],
        detectedCodes: detectedCodes,
        highlights: highlights,
        mentions: mentions,
        dateDelivered: message.dateDelivered,
        dateRead: message.dateRead
    )
}
```

**Step 7: Build client**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds (may need to fix existing Message init calls that now have new params â€” all have defaults so should be fine)

**Step 8: Commit**

```
feat(client): add dateDelivered, dateRead, and DeliveryStatus to Message
```

---

## Task 5: Add `DecoratorContext` and Update `BubbleDecorator` Protocol

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/Protocols/BubbleDecorator.swift`
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/Decorators/TapbackDecorator.swift`
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/Decorators/TimestampDecorator.swift` (if exists)
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/Registries/DecoratorRegistry.swift`
- Modify: `MessageBridgeClient/Tests/MessageBridgeClientCoreTests/Mocks/MockBubbleDecorator.swift`

**Step 1: Write failing tests for DecoratorContext**

Create `MessageBridgeClient/Tests/MessageBridgeClientCoreTests/Decorators/ReadReceiptDecoratorTests.swift`:

```swift
import XCTest

@testable import MessageBridgeClientCore

final class ReadReceiptDecoratorTests: XCTestCase {
    let decorator = ReadReceiptDecorator()

    func testId() {
        XCTAssertEqual(decorator.id, "read-receipt")
    }

    func testPosition_isBottomTrailing() {
        XCTAssertEqual(decorator.position, .bottomTrailing)
    }

    // shouldDecorate tests â€” these will fail until we implement

    func testShouldDecorate_sentMessageAsLastSent_withDelivered_returnsTrue() {
        let msg = Message(
            id: 1, guid: "g1", text: "Hi", date: Date(), isFromMe: true, handleId: nil,
            conversationId: "c1", dateDelivered: Date())
        let context = DecoratorContext(isLastSentMessage: true, isLastMessage: true, conversationId: "c1")
        XCTAssertTrue(decorator.shouldDecorate(msg, context: context))
    }

    func testShouldDecorate_sentMessageAsLastSent_withRead_returnsTrue() {
        let msg = Message(
            id: 1, guid: "g1", text: "Hi", date: Date(), isFromMe: true, handleId: nil,
            conversationId: "c1", dateRead: Date())
        let context = DecoratorContext(isLastSentMessage: true, isLastMessage: true, conversationId: "c1")
        XCTAssertTrue(decorator.shouldDecorate(msg, context: context))
    }

    func testShouldDecorate_sentMessageNotLastSent_returnsFalse() {
        let msg = Message(
            id: 1, guid: "g1", text: "Hi", date: Date(), isFromMe: true, handleId: nil,
            conversationId: "c1", dateDelivered: Date())
        let context = DecoratorContext(isLastSentMessage: false, isLastMessage: false, conversationId: "c1")
        XCTAssertFalse(decorator.shouldDecorate(msg, context: context))
    }

    func testShouldDecorate_receivedMessage_returnsFalse() {
        let msg = Message(
            id: 1, guid: "g1", text: "Hi", date: Date(), isFromMe: false, handleId: 1,
            conversationId: "c1")
        let context = DecoratorContext(isLastSentMessage: false, isLastMessage: true, conversationId: "c1")
        XCTAssertFalse(decorator.shouldDecorate(msg, context: context))
    }

    func testShouldDecorate_sentWithNoStatus_returnsFalse() {
        // isFromMe but no dateDelivered/dateRead â†’ deliveryStatus is .sent
        // We still show "Sent" so this should return true
        let msg = Message(
            id: 1, guid: "g1", text: "Hi", date: Date(), isFromMe: true, handleId: nil,
            conversationId: "c1")
        let context = DecoratorContext(isLastSentMessage: true, isLastMessage: true, conversationId: "c1")
        // .sent status should still show
        XCTAssertTrue(decorator.shouldDecorate(msg, context: context))
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `cd MessageBridgeClient && swift test`
Expected: FAIL â€” ReadReceiptDecorator doesn't exist, DecoratorContext doesn't exist, shouldDecorate signature wrong

**Step 3: Add `DecoratorContext` and update protocol**

In `BubbleDecorator.swift`:

```swift
import SwiftUI

/// Context passed to decorators for decision-making.
public struct DecoratorContext: Sendable {
    /// Whether this message is the last one sent by the current user in the conversation
    public let isLastSentMessage: Bool
    /// Whether this message is the very last message in the conversation
    public let isLastMessage: Bool
    /// The conversation this message belongs to
    public let conversationId: String

    public init(isLastSentMessage: Bool, isLastMessage: Bool, conversationId: String) {
        self.isLastSentMessage = isLastSentMessage
        self.isLastMessage = isLastMessage
        self.conversationId = conversationId
    }
}

/// Position of a decorator relative to the message bubble.
public enum DecoratorPosition: String, Codable, Sendable {
    case topLeading
    case topTrailing
    case bottomLeading
    case bottomTrailing
    case below
    case overlay
}

/// Protocol for adding decorations around message bubbles.
///
/// Unlike renderers which select ONE best match, multiple decorators
/// can coexist at different positions around the bubble.
public protocol BubbleDecorator: Identifiable, Sendable {
    var id: String { get }
    var position: DecoratorPosition { get }
    func shouldDecorate(_ message: Message, context: DecoratorContext) -> Bool
    @MainActor func decorate(_ message: Message, context: DecoratorContext) -> AnyView
}
```

**Step 4: Update DecoratorRegistry**

In `DecoratorRegistry.swift`, update the `decorators(for:at:)` method to accept context:

```swift
public func decorators(for message: Message, at position: DecoratorPosition, context: DecoratorContext)
    -> [any BubbleDecorator]
{
    lock.lock()
    defer { lock.unlock() }
    return decorators.filter { $0.position == position && $0.shouldDecorate(message, context: context) }
}
```

**Step 5: Update TapbackDecorator**

```swift
public func shouldDecorate(_ message: Message, context: DecoratorContext) -> Bool {
    guard let tapbacks = message.tapbacks else { return false }
    return !tapbacks.isEmpty
}

@MainActor
public func decorate(_ message: Message, context: DecoratorContext) -> AnyView {
    AnyView(
        TapbackPill(tapbacks: message.tapbacks ?? [])
            .offset(x: 8, y: -8)
    )
}
```

**Step 6: Update TimestampDecorator** (find and update same pattern)

Search for TimestampDecorator in the codebase and update its `shouldDecorate` and `decorate` signatures similarly â€” just add the `context:` parameter, ignoring it.

**Step 7: Update MockBubbleDecorator**

```swift
func shouldDecorate(_ message: Message, context: DecoratorContext) -> Bool {
    shouldDecorateCallCount += 1
    return shouldDecorateResult
}

@MainActor
func decorate(_ message: Message, context: DecoratorContext) -> AnyView {
    AnyView(Text("Mock decoration"))
}
```

**Step 8: Build client**

Run: `cd MessageBridgeClient && swift build`
Expected: Build fails on MessageBubble view (old call sites) â€” fix in next task

**Step 9: Commit**

```
refactor(client): add DecoratorContext to BubbleDecorator protocol
```

---

## Task 6: Update MessageBubble View to Pass DecoratorContext

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClient/Views/MessageThreadView.swift`

**Step 1: Add `isLastSentMessage` and `isLastMessage` props to MessageBubble**

Add to MessageBubble struct:

```swift
var isLastSentMessage: Bool = false
var isLastMessage: Bool = false
```

**Step 2: Compute and pass context in decorator calls**

Replace the `.below` decorator ForEach:

```swift
// Below decorators (timestamp, read receipts, etc.)
let decoratorContext = DecoratorContext(
    isLastSentMessage: isLastSentMessage,
    isLastMessage: isLastMessage,
    conversationId: message.conversationId
)
ForEach(DecoratorRegistry.shared.decorators(for: message, at: .below, context: decoratorContext), id: \.id) {
    decorator in
    decorator.decorate(message, context: decoratorContext)
}
```

Also add a section for `.bottomTrailing` decorators after the `.below` block:

```swift
// Bottom trailing decorators (read receipts)
ForEach(DecoratorRegistry.shared.decorators(for: message, at: .bottomTrailing, context: decoratorContext), id: \.id) {
    decorator in
    decorator.decorate(message, context: decoratorContext)
}
```

**Step 3: Pass `isLastSentMessage` and `isLastMessage` from MessageThreadView**

In the ForEach that creates MessageBubble instances (around line 44), compute:

```swift
let messagesArray = Array(reversedMessages)
ForEach(Array(messagesArray.enumerated()), id: \.element.id) { index, message in
    let previousMessage = index > 0 ? messagesArray[index - 1] : nil
    let showSenderInfo = shouldShowSenderInfo(
        for: message, previousMessage: previousMessage)
    let isLastMessage = index == messagesArray.count - 1
    let isLastSentMessage = message.isFromMe && !messagesArray[(index + 1)...].contains { $0.isFromMe }
    MessageBubble(
        message: message,
        isGroupConversation: conversation.isGroup,
        sender: senderForMessage(message),
        showSenderInfo: showSenderInfo,
        isLastSentMessage: isLastSentMessage,
        isLastMessage: isLastMessage
    )
}
```

**Step 4: Build client**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds

**Step 5: Commit**

```
feat(client): pass DecoratorContext through MessageBubble to decorators
```

---

## Task 7: Implement ReadReceiptDecorator

**Files:**
- Create: `MessageBridgeClient/Sources/MessageBridgeClientCore/Decorators/ReadReceiptDecorator.swift`

**Step 1: Create ReadReceiptDecorator and ReadReceiptView**

```swift
import SwiftUI

/// Decorator that shows delivery status below the last sent message.
///
/// Displays "Sent", "Delivered", or "Read" at the bottom-trailing position.
/// Tap toggles visibility of the timestamp.
public struct ReadReceiptDecorator: BubbleDecorator {
    public let id = "read-receipt"
    public let position = DecoratorPosition.bottomTrailing

    public init() {}

    public func shouldDecorate(_ message: Message, context: DecoratorContext) -> Bool {
        guard message.isFromMe, context.isLastSentMessage else { return false }
        return message.deliveryStatus != .none
    }

    @MainActor
    public func decorate(_ message: Message, context: DecoratorContext) -> AnyView {
        AnyView(
            ReadReceiptView(
                status: message.deliveryStatus,
                dateRead: message.dateRead,
                dateDelivered: message.dateDelivered
            )
        )
    }
}

struct ReadReceiptView: View {
    let status: DeliveryStatus
    let dateRead: Date?
    let dateDelivered: Date?
    @State private var showTimestamp = false

    var body: some View {
        Text(displayText)
            .font(.caption2)
            .foregroundStyle(.secondary)
            .onTapGesture { showTimestamp.toggle() }
    }

    private var displayText: String {
        switch status {
        case .read:
            return showTimestamp ? "Read \(formatted(dateRead))" : "Read"
        case .delivered:
            return showTimestamp ? "Delivered \(formatted(dateDelivered))" : "Delivered"
        case .sent:
            return "Sent"
        case .none:
            return ""
        }
    }

    private func formatted(_ date: Date?) -> String {
        guard let date else { return "" }
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        formatter.dateStyle = .none
        return formatter.string(from: date)
    }
}
```

**Step 2: Run tests**

Run: `cd MessageBridgeClient && swift test`
Expected: ReadReceiptDecoratorTests pass

**Step 3: Commit**

```
feat(client): implement ReadReceiptDecorator with delivery status display
```

---

## Task 8: Register ReadReceiptDecorator

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClient/App/AppRegistration.swift` (or wherever decorators are registered)

Search for where `TapbackDecorator()` is registered and add alongside it:

```swift
DecoratorRegistry.shared.register(ReadReceiptDecorator())
```

If there's no AppRegistration.swift, search for `DecoratorRegistry.shared.register` to find the registration location.

**Step 1: Find registration location**

Search codebase for `TapbackDecorator()` to find where it's registered.

**Step 2: Add registration**

Add `DecoratorRegistry.shared.register(ReadReceiptDecorator())` adjacent to the existing decorator registration.

**Step 3: Build and run tests**

Run: `cd MessageBridgeClient && swift test`
Expected: All tests pass

**Step 4: Commit**

```
feat(client): register ReadReceiptDecorator in app startup
```

---

## Task 9: Run Full Test Suite and Verify

**Files:** None (verification only)

**Step 1: Run server tests**

Run: `cd MessageBridgeServer && swift test`
Expected: All tests pass

**Step 2: Run client tests**

Run: `cd MessageBridgeClient && swift test`
Expected: All tests pass

**Step 3: Commit any fixups if needed**

---

## Task 10: Update CLAUDE.md and spec.md

**Files:**
- Modify: `CLAUDE.md` â€” Update "Current Focus" section and milestone tracker
- Modify: `spec.md` â€” Update M4.2 status

**Step 1: Update CLAUDE.md "Current Focus"**

```markdown
**Active Work:** None - ready for new work

**Last Session:** M4.2 Read Receipts
- Added `dateDelivered` and `dateRead` to Message models (server + client)
- Added `DecoratorContext` to BubbleDecorator protocol
- Implemented ReadReceiptDecorator (bottomTrailing position)
- Wired up decorator context passing in MessageBubble
- Mark-as-read was already implemented via selectConversation()
```

**Step 2: Update milestone tracker in CLAUDE.md**

Change M4.2 row to:

```
| M4.2 Read Receipts         | âœ…                 | âœ…         | âœ…       | â¬œ       |
```

**Step 3: Update spec.md M4.1 and M4.2 status**

Mark M4.1 as ðŸ”µ (it was implemented in recent commits):
```
### M4.1: Tapbacks (Reactions) ðŸ”µ
```

Mark M4.2:
```
### M4.2: Read Receipts ðŸ”µ
```

**Step 4: Commit**

```
docs: update CLAUDE.md and spec.md for M4.2 read receipts
```
