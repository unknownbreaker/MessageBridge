# M4.2 Read Receipts — Design

**Date:** 2026-01-28
**Status:** Ready for implementation
**Spec ref:** Phase 4, M4.2: Read Receipts

---

## Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Display style | iMessage-native | "Delivered"/"Read" below last sent message, timestamp on tap |
| Read detection | Poll on load | Better performance — avoids watching for field updates on existing rows |
| Mark-as-read trigger | On conversation visible | Matches native iMessage behavior |
| Protocol change | Add DecoratorContext | Clean long-term design for all decorators needing context |

---

## Data Model Changes

### Server — `Message.swift`

Add two optional fields to the server Message model:

```swift
public let dateDelivered: Date?  // m.date_delivered from chat.db
public let dateRead: Date?       // m.date_read from chat.db
```

### Client — `Models.swift`

Add matching fields plus computed delivery status:

```swift
public let dateDelivered: Date?
public let dateRead: Date?

public var deliveryStatus: DeliveryStatus {
    if dateRead != nil { return .read }
    if dateDelivered != nil { return .delivered }
    if isFromMe { return .sent }
    return .none
}

public enum DeliveryStatus: String, Codable, Sendable {
    case none       // Received messages
    case sent       // Sent, no confirmation
    case delivered  // Delivered to device
    case read       // Recipient opened conversation
}
```

### Database Query

Add `m.date_delivered` and `m.date_read` to all message fetch SQL queries in `ChatDatabase.swift`. Convert using `Message.dateFromAppleTimestamp()`.

---

## ReadReceiptDecorator

**File:** `Decorators/ReadReceiptDecorator.swift`

- Position: `.bottomTrailing`
- Only decorates the last sent message in the conversation
- Shows "Delivered" / "Read" text (`.caption2`, `.secondary`)
- Tap toggles timestamp visibility ("Read 3:42 PM")

### shouldDecorate logic

```swift
guard message.isFromMe,
      context.isLastSentMessage,
      message.deliveryStatus != .none else {
    return false
}
return true
```

---

## DecoratorContext (Protocol Change)

Update `BubbleDecorator` protocol to pass context:

```swift
public struct DecoratorContext {
    public let isLastSentMessage: Bool
    public let isLastMessage: Bool
    public let conversationId: String
}

public protocol BubbleDecorator: Identifiable {
    var id: String { get }
    var position: DecoratorPosition { get }
    func shouldDecorate(_ message: Message, context: DecoratorContext) -> Bool
    @MainActor func decorate(_ message: Message, context: DecoratorContext) -> AnyView
}
```

All existing decorators (TapbackDecorator, etc.) update their signatures to accept context (ignoring it if not needed).

---

## Mark Conversation as Read

### Flow

```
User opens conversation
  → MessageThreadView .task(id: conversation.id)
  → MessagesViewModel.markAsRead(conversationId:)
  → POST /conversations/:id/read
  → ChatDatabase.markConversationAsRead() (existing)
  → Updates chat.db + opens Messages.app in background
```

### API Endpoint

```
POST /conversations/:id/read → 200 OK
```

### ViewModel

```swift
@MainActor
func markAsRead(conversationId: String) async {
    guard conversation.unreadCount > 0 else { return }
    do {
        try await bridgeClient.markConversationAsRead(conversationId)
        updateConversationUnreadCount(conversationId, count: 0)
    } catch {
        // Non-critical, will sync eventually
    }
}
```

---

## File Changes

### Server (3 files)

| File | Change |
|------|--------|
| `Models/Message.swift` | Add `dateDelivered`, `dateRead` fields |
| `Database/ChatDatabase.swift` | Add `date_delivered`, `date_read` to SQL queries |
| `API/Routes.swift` | Add `POST /conversations/:id/read` endpoint |

### Client (8 files)

| File | Change |
|------|--------|
| `Models/Models.swift` | Add `dateDelivered`, `dateRead`, `DeliveryStatus` |
| `Protocols/BubbleDecorator.swift` | Add `DecoratorContext` to method signatures |
| `Decorators/TapbackDecorator.swift` | Update signature (ignore context) |
| `Decorators/ReadReceiptDecorator.swift` | **New** — decorator + ReadReceiptView |
| `Registries/DecoratorRegistry.swift` | Register ReadReceiptDecorator |
| `ViewModels/MessagesViewModel.swift` | Add `markAsRead()`, compute `isLastSentMessage` |
| `Views/Messages/MessageBubble.swift` | Pass `DecoratorContext` to decorators |
| `Views/Messages/MessageThreadView.swift` | Call `markAsRead` on appear |

### Tests (2 files)

| File | Scope |
|------|-------|
| `Decorators/ReadReceiptDecoratorTests.swift` | **New** — shouldDecorate logic, status rendering |
| `ViewModels/MessagesViewModelTests.swift` | Mark-as-read test cases |

---

## Not in Scope

- Real-time read receipt updates via WebSocket (can add later if needed)
- Read receipts for group chats (iMessage shows per-participant — future enhancement)
- "Send read receipts" toggle (could add in settings later)
