# M4.1 Tapbacks Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Display tapbacks on message bubbles, send tapbacks via API, sync in real-time via WebSocket.

**Architecture:** Server reads tapbacks from chat.db (associated_message_type 2000-3005), includes them in message responses, and broadcasts changes via WebSocket. Client renders tapbacks as pills on bubbles and sends new tapbacks via POST endpoint.

**Tech Stack:** Swift, Vapor (server), SwiftUI (client), GRDB (database), WebSocket

**Design Document:** `docs/plans/2026-01-28-m4.1-tapbacks.md`

---

## Task 1: Server â€” Add Tapback and TapbackType Models

**Files:**
- Create: `MessageBridgeServer/Sources/MessageBridgeCore/Models/Tapback.swift`

**Step 1: Create Tapback model file**

```swift
import Foundation

/// Represents a tapback (reaction) on a message.
/// Raw values match Apple's `associated_message_type` in chat.db:
/// - 2000-2005: Add tapback
/// - 3000-3005: Remove tapback
public enum TapbackType: Int, Codable, Sendable, CaseIterable {
    case love = 2000      // â¤ï¸
    case like = 2001      // ðŸ‘
    case dislike = 2002   // ðŸ‘Ž
    case laugh = 2003     // ðŸ˜‚
    case emphasis = 2004  // â€¼ï¸
    case question = 2005  // â“

    /// The emoji representation
    public var emoji: String {
        switch self {
        case .love: return "â¤ï¸"
        case .like: return "ðŸ‘"
        case .dislike: return "ðŸ‘Ž"
        case .laugh: return "ðŸ˜‚"
        case .emphasis: return "â€¼ï¸"
        case .question: return "â“"
        }
    }

    /// The removal type (3000-range) for this tapback
    public var removalType: Int {
        rawValue + 1000
    }

    /// Initialize from a raw value that might be add (2000-range) or remove (3000-range)
    public static func from(associatedType: Int) -> (type: TapbackType, isRemoval: Bool)? {
        if let type = TapbackType(rawValue: associatedType) {
            return (type, false)
        }
        if associatedType >= 3000 && associatedType <= 3005,
           let type = TapbackType(rawValue: associatedType - 1000) {
            return (type, true)
        }
        return nil
    }
}

public struct Tapback: Codable, Sendable, Equatable {
    public let type: TapbackType
    public let sender: String        // handle ID (e.g., "+15551234567")
    public let isFromMe: Bool
    public let date: Date
    public let messageGUID: String   // GUID of the target message

    public init(type: TapbackType, sender: String, isFromMe: Bool, date: Date, messageGUID: String) {
        self.type = type
        self.sender = sender
        self.isFromMe = isFromMe
        self.date = date
        self.messageGUID = messageGUID
    }
}
```

**Step 2: Verify it compiles**

Run: `cd MessageBridgeServer && swift build 2>&1 | head -20`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add MessageBridgeServer/Sources/MessageBridgeCore/Models/Tapback.swift
git commit -m "feat(server): add Tapback and TapbackType models"
```

---

## Task 2: Server â€” Add tapbacks Field to Message and ProcessedMessage

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/Models/Message.swift`
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/Models/ProcessedMessage.swift`

**Step 1: Add tapbacks to Message**

In `Message.swift`, add after `attachments`:

```swift
    public var tapbacks: [Tapback]

    public init(
        id: Int64,
        guid: String,
        text: String?,
        date: Date,
        isFromMe: Bool,
        handleId: Int64?,
        conversationId: String,
        attachments: [Attachment] = [],
        tapbacks: [Tapback] = []
    ) {
        self.id = id
        self.guid = guid
        self.text = text
        self.date = date
        self.isFromMe = isFromMe
        self.handleId = handleId
        self.conversationId = conversationId
        self.attachments = attachments
        self.tapbacks = tapbacks
    }
```

**Step 2: Add tapbacks to ProcessedMessage**

In `ProcessedMessage.swift`, add field and update init:

```swift
    public let tapbacks: [Tapback]
```

And in `init(from message:)`:

```swift
    self.tapbacks = message.tapbacks
```

**Step 3: Run tests to find breakages**

Run: `cd MessageBridgeServer && swift test 2>&1 | grep -E "(error:|failed|passed)"`
Expected: Some tests may fail due to init signature changes

**Step 4: Fix test breakages**

Update any test files that create `Message` instances to include `tapbacks: []` parameter.

**Step 5: Verify tests pass**

Run: `cd MessageBridgeServer && swift test`
Expected: All tests pass

**Step 6: Commit**

```bash
git add -A
git commit -m "feat(server): add tapbacks field to Message and ProcessedMessage"
```

---

## Task 3: Server â€” Add TapbackQueries for Reading from chat.db

**Files:**
- Create: `MessageBridgeServer/Sources/MessageBridgeCore/Database/TapbackQueries.swift`
- Create: `MessageBridgeServer/Tests/MessageBridgeCoreTests/Database/TapbackQueriesTests.swift`

**Step 1: Write failing test**

```swift
import Testing
@testable import MessageBridgeCore

@Suite("TapbackQueries Tests")
struct TapbackQueriesTests {
    @Test("Fetches tapbacks for message GUIDs")
    func fetchesTapbacksForMessages() async throws {
        // Create test database with tapback rows
        let db = try TestDatabase.inMemory()
        try db.setupTapbackTestData()

        let queries = TapbackQueries(database: db)
        let tapbacks = try await queries.tapbacks(forMessageGUIDs: ["msg-guid-1", "msg-guid-2"])

        #expect(tapbacks["msg-guid-1"]?.count == 2)  // love + like
        #expect(tapbacks["msg-guid-2"]?.count == 1)  // laugh
    }

    @Test("Handles tapback removal (3000-range cancels 2000-range)")
    func handlesRemoval() async throws {
        let db = try TestDatabase.inMemory()
        try db.setupTapbackRemovalTestData()  // Has add then remove from same sender

        let queries = TapbackQueries(database: db)
        let tapbacks = try await queries.tapbacks(forMessageGUIDs: ["msg-guid-1"])

        // The removal should cancel the add
        #expect(tapbacks["msg-guid-1"]?.isEmpty ?? true)
    }

    @Test("Keeps only latest tapback per sender per type")
    func deduplicatesBySenderAndType() async throws {
        let db = try TestDatabase.inMemory()
        try db.setupDuplicateTapbackTestData()  // Same sender adds love twice

        let queries = TapbackQueries(database: db)
        let tapbacks = try await queries.tapbacks(forMessageGUIDs: ["msg-guid-1"])

        // Should only have one love from that sender
        let loveCount = tapbacks["msg-guid-1"]?.filter { $0.type == .love }.count ?? 0
        #expect(loveCount == 1)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd MessageBridgeServer && swift test --filter TapbackQueriesTests 2>&1 | head -20`
Expected: FAIL - TapbackQueries not found

**Step 3: Implement TapbackQueries**

```swift
import Foundation
import GRDB

/// Queries for reading tapbacks from chat.db
public struct TapbackQueries: Sendable {
    private let database: DatabaseReader

    public init(database: DatabaseReader) {
        self.database = database
    }

    /// Fetch tapbacks for a set of message GUIDs.
    /// Returns a dictionary mapping message GUID to its tapbacks.
    public func tapbacks(forMessageGUIDs guids: [String]) async throws -> [String: [Tapback]] {
        guard !guids.isEmpty else { return [:] }

        return try await database.read { db in
            // Query: Find all tapback messages (2000-3005 range) that reference our target messages
            // The `associated_message_guid` column contains the GUID of the message being reacted to
            // We need to join with handle table to get the sender ID
            let placeholders = guids.map { _ in "?" }.joined(separator: ", ")
            let sql = """
                SELECT
                    m.ROWID,
                    m.guid,
                    m.associated_message_guid,
                    m.associated_message_type,
                    m.is_from_me,
                    m.date,
                    COALESCE(h.id, '') as sender
                FROM message m
                LEFT JOIN handle h ON m.handle_id = h.ROWID
                WHERE m.associated_message_guid IN (\(placeholders))
                  AND m.associated_message_type BETWEEN 2000 AND 3005
                ORDER BY m.date ASC
                """

            let rows = try Row.fetchAll(db, sql: sql, arguments: StatementArguments(guids))

            // Process rows: track adds and removes per (targetGUID, sender, type)
            var tapbacksByMessage: [String: [Tapback]] = [:]
            var processed: [String: [String: [TapbackType: (add: Tapback?, removed: Bool)]]] = [:]
            // processed[messageGUID][sender][type] = (latestAdd, wasRemoved)

            for row in rows {
                guard let associatedGUID = row["associated_message_guid"] as? String,
                      let associatedType = row["associated_message_type"] as? Int,
                      let parsed = TapbackType.from(associatedType: associatedType) else {
                    continue
                }

                let sender = row["sender"] as? String ?? ""
                let isFromMe = (row["is_from_me"] as? Int ?? 0) == 1
                let dateValue = row["date"] as? Int64 ?? 0
                let date = Date(timeIntervalSince1970: TimeInterval(dateValue) / 1_000_000_000 + 978307200)

                // Initialize nested dictionaries if needed
                if processed[associatedGUID] == nil {
                    processed[associatedGUID] = [:]
                }
                if processed[associatedGUID]![sender] == nil {
                    processed[associatedGUID]![sender] = [:]
                }

                if parsed.isRemoval {
                    // Mark as removed
                    processed[associatedGUID]![sender]![parsed.type] = (add: nil, removed: true)
                } else {
                    // Add tapback (overwrite previous if exists, unless already removed)
                    let current = processed[associatedGUID]![sender]![parsed.type]
                    if current?.removed != true {
                        let tapback = Tapback(
                            type: parsed.type,
                            sender: sender,
                            isFromMe: isFromMe,
                            date: date,
                            messageGUID: associatedGUID
                        )
                        processed[associatedGUID]![sender]![parsed.type] = (add: tapback, removed: false)
                    }
                }
            }

            // Flatten to final result
            for (messageGUID, senderMap) in processed {
                var tapbacks: [Tapback] = []
                for (_, typeMap) in senderMap {
                    for (_, state) in typeMap {
                        if let tapback = state.add, !state.removed {
                            tapbacks.append(tapback)
                        }
                    }
                }
                if !tapbacks.isEmpty {
                    tapbacksByMessage[messageGUID] = tapbacks.sorted { $0.date < $1.date }
                }
            }

            return tapbacksByMessage
        }
    }
}
```

**Step 4: Add test database helpers**

Create helper methods in the test file or a TestDatabase extension to set up test data.

**Step 5: Run tests**

Run: `cd MessageBridgeServer && swift test --filter TapbackQueriesTests`
Expected: All tests pass

**Step 6: Commit**

```bash
git add -A
git commit -m "feat(server): add TapbackQueries for reading tapbacks from chat.db"
```

---

## Task 4: Server â€” Integrate Tapbacks into MessageQueries

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/Database/MessageQueries.swift`
- Modify: `MessageBridgeServer/Tests/MessageBridgeCoreTests/Database/MessageQueriesTests.swift`

**Step 1: Write failing test**

Add to existing `MessageQueriesTests.swift`:

```swift
@Test("Messages include tapbacks")
func messagesIncludeTapbacks() async throws {
    let db = try TestDatabase.inMemory()
    try db.setupMessagesWithTapbacks()

    let queries = MessageQueries(database: db)
    let messages = try await queries.messages(forConversation: "chat-1", limit: 10, before: nil)

    let messageWithTapback = messages.first { $0.guid == "msg-with-tapback" }
    #expect(messageWithTapback != nil)
    #expect(messageWithTapback?.tapbacks.isEmpty == false)
    #expect(messageWithTapback?.tapbacks.first?.type == .love)
}
```

**Step 2: Run test to verify it fails**

Run: `cd MessageBridgeServer && swift test --filter "messagesIncludeTapbacks"`
Expected: FAIL - tapbacks array is empty

**Step 3: Update MessageQueries to fetch tapbacks**

In the `messages(forConversation:limit:before:)` method, after fetching messages:

```swift
// Fetch tapbacks for these messages
let messageGUIDs = messages.map { $0.guid }
let tapbackQueries = TapbackQueries(database: database)
let tapbacksByGUID = try await tapbackQueries.tapbacks(forMessageGUIDs: messageGUIDs)

// Attach tapbacks to messages
let messagesWithTapbacks = messages.map { message in
    var updated = message
    updated.tapbacks = tapbacksByGUID[message.guid] ?? []
    return updated
}

return messagesWithTapbacks
```

**Step 4: Run tests**

Run: `cd MessageBridgeServer && swift test`
Expected: All tests pass

**Step 5: Commit**

```bash
git add -A
git commit -m "feat(server): integrate tapbacks into MessageQueries"
```

---

## Task 5: Server â€” Add WebSocket Message Types for Tapbacks

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/API/WebSocketMessages.swift`

**Step 1: Add new message types**

```swift
public enum WebSocketMessageType: String, Codable, Sendable {
    case newMessage = "new_message"
    case connected = "connected"
    case error = "error"
    case tapbackAdded = "tapback_added"
    case tapbackRemoved = "tapback_removed"
}
```

**Step 2: Add TapbackEvent payload struct**

```swift
public struct TapbackEvent: Codable, Sendable {
    public let messageGUID: String
    public let tapbackType: String  // "love", "like", etc.
    public let sender: String
    public let isFromMe: Bool

    public init(messageGUID: String, tapbackType: TapbackType, sender: String, isFromMe: Bool) {
        self.messageGUID = messageGUID
        self.tapbackType = String(describing: tapbackType)
        self.sender = sender
        self.isFromMe = isFromMe
    }
}
```

**Step 3: Verify it compiles**

Run: `cd MessageBridgeServer && swift build`
Expected: Build succeeds

**Step 4: Commit**

```bash
git add -A
git commit -m "feat(server): add WebSocket message types for tapback events"
```

---

## Task 6: Server â€” Add POST /messages/:id/tapback Endpoint

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/API/Routes.swift`
- Create: `MessageBridgeServer/Tests/MessageBridgeCoreTests/API/TapbackRoutesTests.swift`

**Step 1: Write failing test**

```swift
import Testing
import Vapor
import XCTVapor
@testable import MessageBridgeCore

@Suite("Tapback Routes Tests")
struct TapbackRoutesTests {
    @Test("POST /messages/:id/tapback validates input")
    func validatesInput() async throws {
        let app = try await TestApp.configured()
        defer { app.shutdown() }

        // Missing type
        try await app.test(.POST, "/messages/123/tapback", beforeRequest: { req in
            req.headers.add(name: "X-API-Key", value: TestApp.apiKey)
            try req.content.encode(["action": "add"])
        }, afterResponse: { res in
            #expect(res.status == .badRequest)
        })

        // Invalid type
        try await app.test(.POST, "/messages/123/tapback", beforeRequest: { req in
            req.headers.add(name: "X-API-Key", value: TestApp.apiKey)
            try req.content.encode(["type": "invalid", "action": "add"])
        }, afterResponse: { res in
            #expect(res.status == .badRequest)
        })
    }

    @Test("POST /messages/:id/tapback returns 200 on valid request")
    func acceptsValidRequest() async throws {
        let app = try await TestApp.configured()
        defer { app.shutdown() }

        try await app.test(.POST, "/messages/123/tapback", beforeRequest: { req in
            req.headers.add(name: "X-API-Key", value: TestApp.apiKey)
            try req.content.encode(["type": "love", "action": "add"])
        }, afterResponse: { res in
            // 200 if successful, 502 if IMCore fails (expected in test env)
            #expect(res.status == .ok || res.status == .badGateway)
        })
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd MessageBridgeServer && swift test --filter TapbackRoutesTests 2>&1 | head -20`
Expected: FAIL - route not found (404)

**Step 3: Add request/response models**

```swift
struct TapbackRequest: Content {
    let type: String      // love, like, dislike, laugh, emphasis, question
    let action: String    // add, remove

    func validate() throws -> (TapbackType, Bool) {
        guard let tapbackType = TapbackType.allCases.first(where: {
            String(describing: $0) == type
        }) else {
            throw Abort(.badRequest, reason: "Invalid tapback type: \(type)")
        }

        guard action == "add" || action == "remove" else {
            throw Abort(.badRequest, reason: "Action must be 'add' or 'remove'")
        }

        return (tapbackType, action == "remove")
    }
}

struct TapbackResponse: Content {
    let success: Bool
    let error: String?
}
```

**Step 4: Add route handler**

In Routes.swift `boot(routes:)`:

```swift
// Tapback endpoint
authenticated.post("messages", ":id", "tapback") { req -> TapbackResponse in
    guard let messageId = req.parameters.get("id") else {
        throw Abort(.badRequest, reason: "Missing message ID")
    }

    let request = try req.content.decode(TapbackRequest.self)
    let (tapbackType, isRemoval) = try request.validate()

    // TODO: Implement IMCore bridge to actually send tapback
    // For now, return success (the tapback will appear when chat.db is updated)
    return TapbackResponse(success: true, error: nil)
}
```

**Step 5: Run tests**

Run: `cd MessageBridgeServer && swift test --filter TapbackRoutesTests`
Expected: All tests pass

**Step 6: Commit**

```bash
git add -A
git commit -m "feat(server): add POST /messages/:id/tapback endpoint"
```

---

## Task 7: Server â€” Detect Tapback Changes in MessageChangeDetector

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/FileWatcher/MessageChangeDetector.swift`
- Modify: Tests as needed

**Step 1: Write failing test**

```swift
@Test("Detects new tapbacks and broadcasts events")
func detectsNewTapbacks() async throws {
    let detector = MessageChangeDetector(database: mockDb)
    let expectation = XCTestExpectation(description: "Tapback event received")

    detector.onTapbackAdded = { tapback in
        #expect(tapback.type == .love)
        expectation.fulfill()
    }

    // Simulate a new tapback row appearing
    try mockDb.insertTapback(type: .love, messageGUID: "msg-1", sender: "+1555")

    await fulfillment(of: [expectation], timeout: 2.0)
}
```

**Step 2: Run test to verify it fails**

Expected: FAIL - onTapbackAdded doesn't exist

**Step 3: Extend MessageChangeDetector**

Add callbacks and detection logic for tapback rows (associated_message_type 2000-3005).

**Step 4: Run tests**

Run: `cd MessageBridgeServer && swift test`
Expected: All tests pass

**Step 5: Commit**

```bash
git add -A
git commit -m "feat(server): detect tapback changes in MessageChangeDetector"
```

---

## Task 8: Server â€” Broadcast Tapback Events via WebSocket

**Files:**
- Modify: `MessageBridgeServer/Sources/MessageBridgeCore/API/WebSocketManager.swift` (or equivalent)

**Step 1: Add broadcast methods**

```swift
func broadcastTapbackAdded(_ tapback: Tapback) {
    let event = TapbackEvent(
        messageGUID: tapback.messageGUID,
        tapbackType: tapback.type,
        sender: tapback.sender,
        isFromMe: tapback.isFromMe
    )
    broadcast(type: .tapbackAdded, data: event)
}

func broadcastTapbackRemoved(_ tapback: Tapback) {
    let event = TapbackEvent(
        messageGUID: tapback.messageGUID,
        tapbackType: tapback.type,
        sender: tapback.sender,
        isFromMe: tapback.isFromMe
    )
    broadcast(type: .tapbackRemoved, data: event)
}
```

**Step 2: Wire up to MessageChangeDetector**

Connect the detector's callbacks to broadcast methods.

**Step 3: Run tests**

Run: `cd MessageBridgeServer && swift test`
Expected: All tests pass

**Step 4: Commit**

```bash
git add -A
git commit -m "feat(server): broadcast tapback events via WebSocket"
```

---

## Task 9: Client â€” Add Tapback and TapbackType Models

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/Models/Models.swift`

**Step 1: Add Tapback types**

```swift
public enum TapbackType: Int, Codable, Sendable, CaseIterable {
    case love = 2000
    case like = 2001
    case dislike = 2002
    case laugh = 2003
    case emphasis = 2004
    case question = 2005

    public var emoji: String {
        switch self {
        case .love: return "â¤ï¸"
        case .like: return "ðŸ‘"
        case .dislike: return "ðŸ‘Ž"
        case .laugh: return "ðŸ˜‚"
        case .emphasis: return "â€¼ï¸"
        case .question: return "â“"
        }
    }
}

public struct Tapback: Codable, Sendable, Equatable, Identifiable {
    public var id: String { "\(messageGUID)-\(sender)-\(type.rawValue)" }
    public let type: TapbackType
    public let sender: String
    public let isFromMe: Bool
    public let date: Date
    public let messageGUID: String

    public init(type: TapbackType, sender: String, isFromMe: Bool, date: Date, messageGUID: String) {
        self.type = type
        self.sender = sender
        self.isFromMe = isFromMe
        self.date = date
        self.messageGUID = messageGUID
    }
}
```

**Step 2: Add tapbacks to Message**

```swift
public var tapbacks: [Tapback]?
```

**Step 3: Verify it compiles**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds

**Step 4: Commit**

```bash
git add -A
git commit -m "feat(client): add Tapback and TapbackType models"
```

---

## Task 10: Client â€” Implement TapbackDecorator

**Files:**
- Create: `MessageBridgeClient/Sources/MessageBridgeClientCore/Decorators/TapbackDecorator.swift`
- Create: `MessageBridgeClient/Tests/MessageBridgeClientCoreTests/Decorators/TapbackDecoratorTests.swift`

**Step 1: Write failing test**

```swift
import Testing
@testable import MessageBridgeClientCore

@Suite("TapbackDecorator Tests")
struct TapbackDecoratorTests {
    @Test("shouldDecorate returns false for messages without tapbacks")
    func shouldNotDecorateWithoutTapbacks() {
        let decorator = TapbackDecorator()
        let message = Message.stub(tapbacks: [])

        #expect(decorator.shouldDecorate(message) == false)
    }

    @Test("shouldDecorate returns true for messages with tapbacks")
    func shouldDecorateWithTapbacks() {
        let decorator = TapbackDecorator()
        let tapback = Tapback(type: .love, sender: "+1555", isFromMe: false, date: Date(), messageGUID: "guid")
        let message = Message.stub(tapbacks: [tapback])

        #expect(decorator.shouldDecorate(message) == true)
    }

    @Test("position is topTrailing")
    func positionIsTopTrailing() {
        let decorator = TapbackDecorator()
        #expect(decorator.position == .topTrailing)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd MessageBridgeClient && swift test --filter TapbackDecoratorTests 2>&1 | head -20`
Expected: FAIL - TapbackDecorator not found

**Step 3: Implement TapbackDecorator**

```swift
import SwiftUI

public struct TapbackDecorator: BubbleDecorator {
    public let id = "tapback"
    public let position = DecoratorPosition.topTrailing

    public init() {}

    public func shouldDecorate(_ message: Message) -> Bool {
        guard let tapbacks = message.tapbacks else { return false }
        return !tapbacks.isEmpty
    }

    @MainActor
    public func decorate(_ message: Message) -> AnyView {
        AnyView(
            TapbackPill(tapbacks: message.tapbacks ?? [])
                .offset(x: 8, y: -8)
        )
    }
}
```

**Step 4: Run tests**

Run: `cd MessageBridgeClient && swift test --filter TapbackDecoratorTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add -A
git commit -m "feat(client): implement TapbackDecorator"
```

---

## Task 11: Client â€” Implement TapbackPill View

**Files:**
- Create: `MessageBridgeClient/Sources/MessageBridgeClientCore/Decorators/TapbackPill.swift`
- Create: `MessageBridgeClient/Tests/MessageBridgeClientCoreTests/Decorators/TapbackPillTests.swift`

**Step 1: Write failing test**

```swift
import Testing
@testable import MessageBridgeClientCore

@Suite("TapbackPill Tests")
struct TapbackPillTests {
    @Test("Groups tapbacks by type with counts")
    func groupsByType() {
        let tapbacks = [
            Tapback(type: .love, sender: "a", isFromMe: false, date: Date(), messageGUID: "g"),
            Tapback(type: .love, sender: "b", isFromMe: false, date: Date(), messageGUID: "g"),
            Tapback(type: .like, sender: "c", isFromMe: false, date: Date(), messageGUID: "g"),
        ]

        let groups = TapbackPill.groupTapbacks(tapbacks)

        #expect(groups.count == 2)
        #expect(groups.first { $0.type == .love }?.count == 2)
        #expect(groups.first { $0.type == .like }?.count == 1)
    }

    @Test("Orders groups by count descending")
    func ordersGroups() {
        let tapbacks = [
            Tapback(type: .like, sender: "a", isFromMe: false, date: Date(), messageGUID: "g"),
            Tapback(type: .love, sender: "b", isFromMe: false, date: Date(), messageGUID: "g"),
            Tapback(type: .love, sender: "c", isFromMe: false, date: Date(), messageGUID: "g"),
        ]

        let groups = TapbackPill.groupTapbacks(tapbacks)

        #expect(groups.first?.type == .love)  // 2 loves before 1 like
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd MessageBridgeClient && swift test --filter TapbackPillTests 2>&1 | head -20`
Expected: FAIL - TapbackPill not found

**Step 3: Implement TapbackPill**

```swift
import SwiftUI

public struct TapbackGroup: Identifiable {
    public var id: Int { type.rawValue }
    public let type: TapbackType
    public let count: Int
}

public struct TapbackPill: View {
    public let tapbacks: [Tapback]

    public init(tapbacks: [Tapback]) {
        self.tapbacks = tapbacks
    }

    public var body: some View {
        HStack(spacing: 2) {
            ForEach(Self.groupTapbacks(tapbacks)) { group in
                HStack(spacing: 1) {
                    Text(group.type.emoji)
                        .font(.system(size: 12))
                    if group.count > 1 {
                        Text("\(group.count)")
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                    }
                }
            }
        }
        .padding(.horizontal, 6)
        .padding(.vertical, 3)
        .background(Capsule().fill(.regularMaterial))
        .overlay(Capsule().stroke(.separator, lineWidth: 0.5))
    }

    public static func groupTapbacks(_ tapbacks: [Tapback]) -> [TapbackGroup] {
        var counts: [TapbackType: Int] = [:]
        for tapback in tapbacks {
            counts[tapback.type, default: 0] += 1
        }

        return counts
            .map { TapbackGroup(type: $0.key, count: $0.value) }
            .sorted { $0.count > $1.count }
    }
}
```

**Step 4: Run tests**

Run: `cd MessageBridgeClient && swift test --filter TapbackPillTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add -A
git commit -m "feat(client): implement TapbackPill view"
```

---

## Task 12: Client â€” Register TapbackDecorator

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClient/App/MessageBridgeApp.swift`

**Step 1: Add registration**

In `setupDecorators()`:

```swift
private func setupDecorators() {
    DecoratorRegistry.shared.register(TimestampDecorator())
    DecoratorRegistry.shared.register(TapbackDecorator())  // Add this
}
```

**Step 2: Verify it compiles and runs**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add -A
git commit -m "feat(client): register TapbackDecorator"
```

---

## Task 13: Client â€” Implement TapbackPicker View

**Files:**
- Create: `MessageBridgeClient/Sources/MessageBridgeClientCore/Views/TapbackPicker.swift`

**Step 1: Implement picker**

```swift
import SwiftUI

public struct TapbackPicker: View {
    public let message: Message
    public let onSelect: (TapbackType, Bool) -> Void  // (type, isRemoval)
    @Environment(\.dismiss) private var dismiss

    public init(message: Message, onSelect: @escaping (TapbackType, Bool) -> Void) {
        self.message = message
        self.onSelect = onSelect
    }

    public var body: some View {
        HStack(spacing: 12) {
            ForEach(TapbackType.allCases, id: \.rawValue) { type in
                TapbackButton(
                    type: type,
                    isSelected: hasMyTapback(of: type),
                    action: {
                        let isRemoval = hasMyTapback(of: type)
                        onSelect(type, isRemoval)
                        dismiss()
                    }
                )
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(RoundedRectangle(cornerRadius: 20).fill(.regularMaterial))
    }

    private func hasMyTapback(of type: TapbackType) -> Bool {
        message.tapbacks?.contains { $0.type == type && $0.isFromMe } ?? false
    }
}

struct TapbackButton: View {
    let type: TapbackType
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            Text(type.emoji)
                .font(.title2)
                .padding(8)
                .background(
                    Circle()
                        .fill(isSelected ? Color.accentColor.opacity(0.3) : Color.clear)
                )
        }
        .buttonStyle(.plain)
    }
}
```

**Step 2: Verify it compiles**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add -A
git commit -m "feat(client): implement TapbackPicker view"
```

---

## Task 14: Client â€” Update TapbackAction to Show Picker

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/Actions/TapbackAction.swift`

**Step 1: Update implementation**

```swift
import SwiftUI

public struct TapbackAction: MessageAction {
    public let id = "tapback"
    public let title = "Tapback"
    public let icon = "face.smiling"
    public let destructive = false

    private let viewModel: MessagesViewModel

    public init(viewModel: MessagesViewModel) {
        self.viewModel = viewModel
    }

    public func isAvailable(for message: Message) -> Bool {
        true
    }

    @MainActor
    public func perform(on message: Message) async {
        // Present picker as popover/sheet
        // This will be wired up in the view layer
        NotificationCenter.default.post(
            name: .showTapbackPicker,
            object: nil,
            userInfo: ["message": message]
        )
    }
}

extension Notification.Name {
    public static let showTapbackPicker = Notification.Name("showTapbackPicker")
}
```

**Step 2: Verify it compiles**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add -A
git commit -m "feat(client): update TapbackAction to trigger picker"
```

---

## Task 15: Client â€” Add sendTapback to MessagesViewModel

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/ViewModels/MessagesViewModel.swift`
- Create: `MessageBridgeClient/Tests/MessageBridgeClientCoreTests/ViewModels/MessagesViewModelTapbackTests.swift`

**Step 1: Write failing test**

```swift
import Testing
@testable import MessageBridgeClientCore

@Suite("MessagesViewModel Tapback Tests")
struct MessagesViewModelTapbackTests {
    @Test("sendTapback calls API with correct parameters")
    func sendTapbackCallsAPI() async throws {
        let mockClient = MockRESTClient()
        let vm = MessagesViewModel(restClient: mockClient)

        await vm.sendTapback(type: .love, messageId: "123", action: .add)

        #expect(mockClient.lastPath == "/messages/123/tapback")
        #expect(mockClient.lastMethod == "POST")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd MessageBridgeClient && swift test --filter MessagesViewModelTapbackTests 2>&1 | head -20`
Expected: FAIL - sendTapback doesn't exist

**Step 3: Implement sendTapback**

```swift
public enum TapbackActionType: String {
    case add
    case remove
}

public func sendTapback(type: TapbackType, messageId: String, action: TapbackActionType) async {
    do {
        let body: [String: String] = [
            "type": String(describing: type),
            "action": action.rawValue
        ]
        try await restClient.post("/messages/\(messageId)/tapback", body: body)
    } catch {
        Logger.shared.error("Failed to send tapback: \(error)")
    }
}
```

**Step 4: Run tests**

Run: `cd MessageBridgeClient && swift test --filter MessagesViewModelTapbackTests`
Expected: All tests pass

**Step 5: Commit**

```bash
git add -A
git commit -m "feat(client): add sendTapback to MessagesViewModel"
```

---

## Task 16: Client â€” Handle WebSocket Tapback Events

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClientCore/ViewModels/MessagesViewModel.swift`

**Step 1: Add handler for tapback events**

In the WebSocket message handler:

```swift
case "tapback_added":
    if let data = message.data,
       let event = try? JSONDecoder().decode(TapbackEvent.self, from: data) {
        handleTapbackAdded(event)
    }

case "tapback_removed":
    if let data = message.data,
       let event = try? JSONDecoder().decode(TapbackEvent.self, from: data) {
        handleTapbackRemoved(event)
    }
```

```swift
private func handleTapbackAdded(_ event: TapbackEvent) {
    // Find the message and add the tapback
    for (conversationId, var msgs) in messages {
        if let index = msgs.firstIndex(where: { $0.guid == event.messageGUID }) {
            var message = msgs[index]
            var tapbacks = message.tapbacks ?? []
            let newTapback = Tapback(
                type: event.tapbackType,
                sender: event.sender,
                isFromMe: event.isFromMe,
                date: Date(),
                messageGUID: event.messageGUID
            )
            tapbacks.append(newTapback)
            message.tapbacks = tapbacks
            msgs[index] = message
            messages[conversationId] = msgs
            return
        }
    }
}

private func handleTapbackRemoved(_ event: TapbackEvent) {
    // Find the message and remove the tapback
    for (conversationId, var msgs) in messages {
        if let index = msgs.firstIndex(where: { $0.guid == event.messageGUID }) {
            var message = msgs[index]
            var tapbacks = message.tapbacks ?? []
            tapbacks.removeAll {
                $0.type == event.tapbackType && $0.sender == event.sender
            }
            message.tapbacks = tapbacks
            msgs[index] = message
            messages[conversationId] = msgs
            return
        }
    }
}
```

**Step 2: Verify it compiles**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add -A
git commit -m "feat(client): handle WebSocket tapback events"
```

---

## Task 17: Client â€” Wire Up TapbackPicker in MessageThreadView

**Files:**
- Modify: `MessageBridgeClient/Sources/MessageBridgeClient/Views/MessageThreadView.swift`

**Step 1: Add state and picker presentation**

```swift
@State private var showingTapbackPicker = false
@State private var tapbackTargetMessage: Message?

// In body, add observer
.onReceive(NotificationCenter.default.publisher(for: .showTapbackPicker)) { notification in
    if let message = notification.userInfo?["message"] as? Message {
        tapbackTargetMessage = message
        showingTapbackPicker = true
    }
}

// Add popover/sheet
.popover(isPresented: $showingTapbackPicker) {
    if let message = tapbackTargetMessage {
        TapbackPicker(message: message) { type, isRemoval in
            Task {
                await viewModel.sendTapback(
                    type: type,
                    messageId: String(message.id),
                    action: isRemoval ? .remove : .add
                )
            }
        }
    }
}
```

**Step 2: Verify it compiles and run manually**

Run: `cd MessageBridgeClient && swift build`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add -A
git commit -m "feat(client): wire up TapbackPicker in MessageThreadView"
```

---

## Task 18: Full Integration Test

**Files:**
- Run both server and client tests

**Step 1: Run all server tests**

Run: `cd MessageBridgeServer && swift test`
Expected: All tests pass

**Step 2: Run all client tests**

Run: `cd MessageBridgeClient && swift test`
Expected: All tests pass

**Step 3: Manual verification**

- Start server, start client
- View a conversation with existing tapbacks â†’ pills appear
- Right-click message â†’ Tapback â†’ picker appears
- Select tapback â†’ sent to server
- Receive tapback from another device â†’ pill updates in real-time

**Step 4: Final commit**

```bash
git add -A
git commit -m "feat: complete M4.1 Tapbacks implementation

- Server: Tapback model, TapbackQueries, API endpoint, WebSocket events
- Client: TapbackDecorator, TapbackPill, TapbackPicker, ViewModel integration
- Real-time sync via WebSocket"
```

---

## Summary

| Task | Component | Description |
|------|-----------|-------------|
| 1 | Server Models | Add Tapback, TapbackType |
| 2 | Server Models | Add tapbacks to Message, ProcessedMessage |
| 3 | Server Database | TapbackQueries for reading from chat.db |
| 4 | Server Database | Integrate into MessageQueries |
| 5 | Server API | WebSocket message types |
| 6 | Server API | POST /messages/:id/tapback endpoint |
| 7 | Server FileWatcher | Detect tapback changes |
| 8 | Server WebSocket | Broadcast tapback events |
| 9 | Client Models | Add Tapback, TapbackType, update Message |
| 10 | Client Decorator | TapbackDecorator |
| 11 | Client View | TapbackPill |
| 12 | Client App | Register decorator |
| 13 | Client View | TapbackPicker |
| 14 | Client Action | Update TapbackAction |
| 15 | Client ViewModel | sendTapback method |
| 16 | Client ViewModel | Handle WebSocket events |
| 17 | Client View | Wire up picker in MessageThreadView |
| 18 | Integration | Full test suite |

**Note:** IMCore bridge for actually sending tapbacks via Apple's private API is documented in the design but marked as "manual testing only" â€” implement if time permits, otherwise tapbacks will sync when chat.db updates from the Messages.app UI.
